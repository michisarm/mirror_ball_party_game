<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ë¯¸ëŸ¬ë³¼ íŒŒí‹°</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #E0C3FC 0%, #D4A5E8 50%, #C5A7E5 100%);
            font-family: 'Fredoka', sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            max-width: 100vw;
            max-height: 100vh;
            background: linear-gradient(180deg, #F8E8FF 0%, #E8D5F5 50%, #D9C3E8 100%);
            border: 8px solid #FFB6E1;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), inset 0 0 30px rgba(255, 255, 255, 0.3);
        }

        @media (max-width: 900px) {
            #gameContainer {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                border: none;
            }
        }

        @media (orientation: portrait) {
            #gameContainer {
                width: 100vw;
                height: 100vh;
            }
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: auto;
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100vh;
            aspect-ratio: 800/600;
        }

        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #8B5A8E;
            font-size: 20px;
            font-weight: 700;
            z-index: 10;
            background: rgba(255, 255, 255, 0.85);
            padding: 12px 20px;
            border-radius: 15px;
            border: 3px solid #FFB6E1;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #ui div {
            margin: 3px 0;
        }

        #timer {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #8B5A8E;
            font-size: 24px;
            font-weight: 700;
            z-index: 10;
            background: rgba(255, 182, 193, 0.9);
            padding: 12px 20px;
            border-radius: 15px;
            border: 3px solid #FFB6E1;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 15px 10px;
            box-sizing: border-box;
        }

        @media (orientation: landscape) and (max-height: 600px) {
            .screen {
                padding: 10px 20px;
                justify-content: flex-start;
                padding-top: 5vh;
            }
        }

        #startScreen {
            background: linear-gradient(135deg, rgba(248, 232, 255, 0.98) 0%, rgba(232, 213, 245, 0.98) 50%, rgba(217, 195, 232, 0.98) 100%);
        }

        #stageTransition,
        #gameOverScreen {
            background: rgba(0, 0, 0, 0.95);
            display: none;
        }

        h1 {
            color: #B794F6;
            font-size: 48px;
            margin: 0 0 15px 0;
            text-shadow: 0 0 30px #E0C3FC, 4px 4px 0 rgba(183, 148, 246, 0.3);
            font-weight: 700;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {

            0%,
            100% {
                text-shadow: 0 0 30px #E0C3FC, 4px 4px 0 rgba(183, 148, 246, 0.3);
            }

            50% {
                text-shadow: 0 0 50px #C5A7E5, 4px 4px 0 rgba(183, 148, 246, 0.3);
            }
        }

        h2 {
            color: #8B5A8E;
            font-size: 26px;
            margin: 8px 0;
            text-shadow: 2px 2px 4px rgba(183, 148, 246, 0.3);
        }

        .info-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 12px 18px;
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            margin: 10px auto;
            max-width: 80vw;
            width: 100%;
        }

        .info-box p {
            color: #8B5A8E;
            font-size: 15px;
            margin: 4px 0;
            font-weight: 600;
            line-height: 1.4;
        }

        button {
            background: linear-gradient(135deg, #FFB6E1 0%, #FFA5D8 100%);
            color: #8B5A8E;
            border: 4px solid #FFF;
            padding: 12px 30px;
            font-size: 22px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 700;
            margin: 8px auto;
            font-family: 'Fredoka', sans-serif;
            box-shadow: 0 8px 25px rgba(255, 182, 225, 0.5);
            transition: transform 0.2s;
            max-width: 80vw;
        }

        button:hover {
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        #rankDisplay {
            background: rgba(255, 255, 255, 0.9);
            padding: 12px;
            border-radius: 15px;
            margin: 8px auto;
            max-width: 80vw;
            width: 100%;
            max-height: 25vh;
            overflow-y: auto;
        }

        #rankDisplay h3 {
            color: #B794F6;
            margin: 0 0 8px 0;
            font-size: 16px;
        }

        #rankList {
            color: #8B5A8E;
            font-size: 13px;
            text-align: left;
        }

        .rank-item {
            padding: 5px;
            margin: 3px 0;
            background: rgba(255, 182, 225, 0.3);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 30px;
            width: 100%;
            justify-content: space-between;
            padding: 0 40px;
            align-items: center;
            z-index: 15;
            pointer-events: none;
        }

        .mobile-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: #8B5A8E;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .mobile-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.4);
        }

        @media (max-width: 800px),
        (max-height: 600px) {
            .mobile-controls {
                display: flex !important;
            }

            #ui,
            #timer {
                font-size: 16px;
                padding: 8px 15px;
            }

            h1 {
                font-size: 42px;
            }

            h2 {
                font-size: 24px;
            }

            .info-box p {
                font-size: 16px;
            }

            button {
                font-size: 22px;
                padding: 15px 35px;
            }
        }

        @media (max-width: 500px) {
            .mobile-btn {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }

            .mobile-controls {
                gap: 60px;
            }

            h1 {
                font-size: 36px;
            }

            .info-box {
                padding: 15px 20px;
                margin: 15px;
            }
        }

        @keyframes sparkle {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(1.2);
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div id="ui">
            <div>âœ¨ Stage: <span id="stageDisplay">1</span></div>
            <div>ğŸ¯ ì ìˆ˜: <span id="score">0</span></div>
        </div>

        <div id="timer">â±ï¸ <span id="timeDisplay">1:00</span></div>

        <div id="startScreen" class="screen">
            <h1>âœ¨ ë¯¸ëŸ¬ë³¼ íŒŒí‹° âœ¨</h1>
            <div class="info-box">
                <h2>ğŸ® ê²Œì„ ë°©ë²•</h2>
                <p>â¬…ï¸ â¡ï¸ ë°©í–¥í‚¤ë¡œ íŒ ì´ë™</p>
                <p>ğŸ”µ êµ¬ìŠ¬ì„ íŠ•ê²¨ì„œ ë¯¸ëŸ¬ë³¼ ê¹¨íŠ¸ë¦¬ê¸°!</p>
                <p>ğŸ’ ì¤‘ì•™ ë¯¸ëŸ¬ë³¼ í„°íŠ¸ë¦¬ë©´ 2ë‹¨ê³„!</p>
                <p>âš ï¸ êµ¬ìŠ¬ì´ ë°”ë‹¥ì— ë–¨ì–´ì§€ë©´ ê²Œì„ ì˜¤ë²„!</p>
                <p>â±ï¸ ì œí•œì‹œê°„ ì•ˆì— ìµœê³ ì ìˆ˜ ë„ì „!</p>
            </div>
            <button onclick="startGame()">ğŸ‰ ê²Œì„ ì‹œì‘! ğŸ‰</button>
        </div>

        <div id="stageTransition" class="screen">
            <h1>ğŸŠ Stage 2! ğŸŠ</h1>
            <div class="info-box">
                <p style="font-size: 20px; color: #B794F6; font-weight: 700;">â­ 1ë‹¨ê³„ í´ë¦¬ì–´! â­</p>
                <p>ì ìˆ˜: <span id="stage1Score"></span></p>
                <p style="color: #FFB6E1; margin-top: 10px; font-weight: 700;">ğŸ’ ë” ë§ì€ ë³´ì„ì„ ëª¨ìœ¼ì„¸ìš”!</p>
                <p>â±ï¸ ì œí•œì‹œê°„: 40ì´ˆ</p>
            </div>
            <button onclick="startStage2()">ğŸš€ 2ë‹¨ê³„ ì‹œì‘!</button>
        </div>

        <div id="gameOverScreen" class="screen">
            <h1>ğŸ‰ ê²Œì„ ì¢…ë£Œ! ğŸ‰</h1>
            <div class="info-box">
                <h2>ìµœì¢… ì ìˆ˜: <span id="finalScore"></span></h2>
                <p id="clearMessage"></p>
            </div>
            <div id="rankDisplay">
                <h3>ğŸ† ìµœê³  ê¸°ë¡ TOP 5 ğŸ†</h3>
                <div id="rankList"></div>
            </div>
            <button onclick="location.reload()">ğŸ”„ ë‹¤ì‹œ í•˜ê¸°</button>
        </div>

        <div class="mobile-controls" id="mobileControls">
            <div class="mobile-btn" id="leftBtn">â¬…ï¸</div>
            <div class="mobile-btn" id="rightBtn">â¡ï¸</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ê²Œì„ ìƒíƒœ
        let gameState = 'start';
        let stage = 1;
        let score = 0;
        let timeLeft = 60;
        let timerInterval = null;
        let highScores = [];

        // ëª¨ë°”ì¼ í„°ì¹˜
        let touchingLeft = false;
        let touchingRight = false;

        // í”Œë ˆì´ì–´ íŒ
        const paddle = {
            x: 350,
            y: 540,
            width: 120,
            height: 15,
            speed: 8
        };

        // êµ¬ìŠ¬
        const ball = {
            x: 400,
            y: 520,
            radius: 10,
            dx: 4,
            dy: -4,
            speed: 4,
            active: true
        };

        // ë¯¸ëŸ¬ë³¼ë“¤
        let mirrorballs = [];
        let bigMirrorball = null;

        // ë²½ëŒë“¤
        let bricks = [];

        // ë–¨ì–´ì§€ëŠ” ë³´ìƒ
        let rewards = [];

        // ìµœê³  ì ìˆ˜ ë¶ˆëŸ¬ì˜¤ê¸°
        function loadHighScores() {
            const saved = localStorage.getItem('mirrorballHighScores');
            highScores = saved ? JSON.parse(saved) : [];
        }

        // ìµœê³  ì ìˆ˜ ì €ì¥
        function saveHighScore(newScore) {
            highScores.push({
                score: newScore,
                date: new Date().toLocaleDateString('ko-KR')
            });
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 5);
            localStorage.setItem('mirrorballHighScores', JSON.stringify(highScores));
        }

        // ìˆœìœ„ í‘œì‹œ
        function displayRankings() {
            const container = document.getElementById('rankList');
            container.innerHTML = '';

            if (highScores.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                return;
            }

            const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ï¸âƒ£', '5ï¸âƒ£'];
            highScores.forEach((record, index) => {
                const item = document.createElement('div');
                item.className = 'rank-item';
                item.innerHTML = `
                    <span>${medals[index]} ${index + 1}ìœ„</span>
                    <span style="color: #667eea; font-weight: 700;">${record.score}ì </span>
                    <span style="font-size: 14px;">${record.date}</span>
                `;
                container.appendChild(item);
            });
        }

        // ë¯¸ëŸ¬ë³¼ ìƒì„±
        function createMirrorballs() {
            mirrorballs = [];
            rewards = [];
            bricks = [];

            // ë²½ëŒ ìƒì„± (3ê°œ - ë¯¸ëŸ¬ë³¼ê³¼ ê²¹ì¹˜ì§€ ì•ŠëŠ” ìœ„ì¹˜)
            bricks.push(
                { x: 80, y: 280, width: 80, height: 30, hp: 3, maxHp: 3 },
                { x: 360, y: 480, width: 80, height: 30, hp: 3, maxHp: 3 },
                { x: 640, y: 280, width: 80, height: 30, hp: 3, maxHp: 3 }
            );

            if (stage === 1) {
                // 1ë‹¨ê³„: ì¤‘ì•™ì— í° ë¯¸ëŸ¬ë³¼, ì£¼ë³€ì— ê³ ì •ëœ ì‘ì€ ë¯¸ëŸ¬ë³¼ë“¤
                bigMirrorball = {
                    x: 400,
                    y: 200,
                    radius: 100,
                    hp: 300,
                    maxHp: 300,
                    color: 0,
                    sparkleAngle: 0
                };

                // ì‘ì€ ë¯¸ëŸ¬ë³¼ë“¤ (ì›í˜• ë°°ì¹˜ - ë§¤ìš° í¬ê²Œ)
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const dist = 240;
                    const is10Points = i % 3 === 0;
                    const size = is10Points ? 45 : 38;
                    mirrorballs.push({
                        x: 400 + Math.cos(angle) * dist,
                        y: 200 + Math.sin(angle) * dist,
                        radius: size,
                        points: is10Points ? 10 : 5,
                        hp: 1,
                        moving: false
                    });
                }

                // ìƒë‹¨ì—ë„ ì¶”ê°€ (ë” í¬ê²Œ)
                for (let i = 0; i < 4; i++) {
                    const is10Points = i % 2 === 0;
                    const size = is10Points ? 45 : 38;
                    mirrorballs.push({
                        x: 200 + i * 133,
                        y: 60,
                        radius: size,
                        points: is10Points ? 10 : 5,
                        hp: 1,
                        moving: false
                    });
                }
            } else {
                // 2ë‹¨ê³„: ì¤‘ì•™ì— í° ë¯¸ëŸ¬ë³¼, ì£¼ë³€ì— ì›€ì§ì´ëŠ” ì‘ì€ ë¯¸ëŸ¬ë³¼ë“¤
                bigMirrorball = {
                    x: 400,
                    y: 200,
                    radius: 100,
                    hp: 500,
                    maxHp: 500,
                    color: 0,
                    sparkleAngle: 0
                };

                // ì›€ì§ì´ëŠ” ì‘ì€ ë¯¸ëŸ¬ë³¼ë“¤ (ë” í¬ê²Œ)
                for (let i = 0; i < 10; i++) {
                    const is10Points = i % 3 === 0;
                    const size = is10Points ? 45 : 38;
                    mirrorballs.push({
                        x: 100 + Math.random() * 600,
                        y: 50 + Math.random() * 250,
                        radius: size,
                        points: is10Points ? 10 : 5,
                        hp: 1,
                        moving: true,
                        dx: (Math.random() - 0.5) * 2.5,
                        dy: (Math.random() - 0.5) * 2.5
                    });
                }
            }
        }

        // ë³´ìƒ ìƒì„± (ë¯¸ëŸ¬ë³¼ì´ ê¹¨ì§ˆ ë•Œ)
        function createRewards(x, y, type) {
            let count = 5;
            if (type === 'big') count = 40;
            else if (type === 'brick') count = 8;

            for (let i = 0; i < count; i++) {
                rewards.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: -Math.random() * 5 - 3,
                    type: type === 'brick' ? 'star' : (stage === 1 ? 'candy' : 'gem'),
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
        }

        // íƒ€ì´ë¨¸ ì‹œì‘
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);

            timerInterval = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                document.getElementById('timeDisplay').textContent =
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        // ê²Œì„ ì‹œì‘
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameState = 'playing';
            stage = 1;
            score = 0;
            timeLeft = 60;
            ball.x = 400;
            ball.y = 520;
            ball.dx = 4;
            ball.dy = -4;
            ball.active = true;
            paddle.x = 350;
            createMirrorballs();
            startTimer();
            document.getElementById('score').textContent = score;
            document.getElementById('stageDisplay').textContent = stage;
        }

        // 2ë‹¨ê³„ ì‹œì‘
        function startStage2() {
            document.getElementById('stageTransition').style.display = 'none';
            gameState = 'playing';
            stage = 2;
            timeLeft = 40;
            ball.x = 400;
            ball.y = 520;
            ball.dx = 5;
            ball.dy = -5;
            ball.active = true;
            paddle.x = 350;
            createMirrorballs();
            startTimer();
            document.getElementById('stageDisplay').textContent = stage;
        }

        // 1ë‹¨ê³„ í´ë¦¬ì–´
        function clearStage1() {
            gameState = 'transition';
            clearInterval(timerInterval);
            document.getElementById('stage1Score').textContent = score + 'ì ';
            document.getElementById('stageTransition').style.display = 'flex';
        }

        // ê²Œì„ ì¢…ë£Œ
        function endGame() {
            gameState = 'gameover';
            clearInterval(timerInterval);
            saveHighScore(score);

            document.getElementById('finalScore').textContent = score + 'ì ';
            const msg = stage === 2 && score >= 1000 ?
                'ğŸŠ 2ë‹¨ê³„ê¹Œì§€ í´ë¦¬ì–´! ëŒ€ë‹¨í•´ìš”! ğŸŠ' :
                stage === 2 ? 'ğŸ’ 2ë‹¨ê³„ ë„ì „ ì™„ë£Œ!' :
                    score >= 500 ? 'ğŸŒŸ 1ë‹¨ê³„ í´ë¦¬ì–´!' :
                        'ğŸ˜Š ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!';
            document.getElementById('clearMessage').textContent = msg;

            displayRankings();
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        // í‚¤ë³´ë“œ ì…ë ¥
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // ëª¨ë°”ì¼ í„°ì¹˜
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchingLeft = true;
        });
        document.getElementById('leftBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            touchingLeft = false;
        });
        document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchingRight = true;
        });
        document.getElementById('rightBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            touchingRight = false;
        });

        // ì¶©ëŒ ê°ì§€
        function checkCircleCollision(c1, c2) {
            const dx = c1.x - c2.x;
            const dy = c1.y - c2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < c1.radius + c2.radius;
        }

        function checkRectCircleCollision(rect, circle) {
            const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
            const dx = circle.x - closestX;
            const dy = circle.y - closestY;
            return (dx * dx + dy * dy) < (circle.radius * circle.radius);
        }

        // ë°°ê²½ ê·¸ë¦¬ê¸°
        function drawBackground() {
            // ê·€ì—¬ìš´ íŒŒìŠ¤í…” ê·¸ë¼ë°ì´ì…˜
            const gradient = ctx.createLinearGradient(0, 0, 0, 600);
            gradient.addColorStop(0, '#F8E8FF');
            gradient.addColorStop(0.3, '#F0DBFF');
            gradient.addColorStop(0.7, '#E8D5F5');
            gradient.addColorStop(1, '#D9C3E8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 800, 600);

            // ê·€ì—¬ìš´ ë°˜ì§ì´ëŠ” ë³„ë“¤ (ë” í¬ê³  ê·€ì—½ê²Œ)
            const time = Date.now() * 0.001;
            for (let i = 0; i < 40; i++) {
                const x = (i * 123 + time * 10) % 800;
                const y = (i * 456) % 500;
                const twinkle = Math.sin(time * 2 + i) * 0.4 + 0.6;

                ctx.save();
                ctx.translate(x, y);
                ctx.globalAlpha = twinkle;

                // ë³„ ëª¨ì–‘
                ctx.fillStyle = '#FFD4E5';
                ctx.beginPath();
                for (let j = 0; j < 5; j++) {
                    const angle = (j / 5) * Math.PI * 2 - Math.PI / 2;
                    const outerR = 4 + (i % 3);
                    const innerR = (4 + (i % 3)) * 0.4;

                    if (j === 0) {
                        ctx.moveTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
                    } else {
                        ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
                    }

                    const innerAngle = angle + Math.PI / 5;
                    ctx.lineTo(Math.cos(innerAngle) * innerR, Math.sin(innerAngle) * innerR);
                }
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            // ê·€ì—¬ìš´ êµ¬ë¦„ (íŒŒìŠ¤í…”í†¤)
            for (let i = 0; i < 8; i++) {
                const cloudX = ((i * 150 + time * 15) % 900) - 50;
                const cloudY = 30 + (i % 3) * 80;

                ctx.fillStyle = 'rgba(255, 228, 240, 0.5)';
                ctx.beginPath();
                ctx.arc(cloudX, cloudY, 25, 0, Math.PI * 2);
                ctx.arc(cloudX + 20, cloudY - 5, 20, 0, Math.PI * 2);
                ctx.arc(cloudX + 40, cloudY, 25, 0, Math.PI * 2);
                ctx.arc(cloudX + 25, cloudY + 10, 18, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalAlpha = 1;
        }

        // íŒ ê·¸ë¦¬ê¸°
        function drawPaddle() {
            const gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
            gradient.addColorStop(0, '#FFD4E5');
            gradient.addColorStop(1, '#FFB6E1');
            ctx.fillStyle = gradient;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);

            // ê·€ì—¬ìš´ í•˜íŠ¸ ì¥ì‹
            ctx.fillStyle = '#FFB6E1';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            for (let i = 0; i < 3; i++) {
                ctx.fillText('â™¥', paddle.x + (i + 1) * 30, paddle.y + 11);
            }
        }

        // êµ¬ìŠ¬ ê·¸ë¦¬ê¸°
        function drawBall() {
            const gradient = ctx.createRadialGradient(ball.x - 3, ball.y - 3, 2, ball.x, ball.y, ball.radius);
            gradient.addColorStop(0, '#FFF');
            gradient.addColorStop(0.3, '#E8D5F5');
            gradient.addColorStop(1, '#C5A7E5');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // ë°˜ì§ì„
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(ball.x - 3, ball.y - 3, 3, 0, Math.PI * 2);
            ctx.fill();

            // í…Œë‘ë¦¬
            ctx.strokeStyle = '#B794F6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // ë²½ëŒ ê·¸ë¦¬ê¸°
        function drawBrick(brick) {
            ctx.save();

            // ë²½ëŒ ê·¸ë¦¼ì
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(brick.x + 3, brick.y + 3, brick.width, brick.height);

            // ì²´ë ¥ì— ë”°ë¥¸ ìƒ‰ìƒ
            const hpPercent = brick.hp / brick.maxHp;
            let color1, color2;
            if (hpPercent > 0.66) {
                color1 = '#B794F6';
                color2 = '#9F7AEA';
            } else if (hpPercent > 0.33) {
                color1 = '#D4A5E8';
                color2 = '#C5A7E5';
            } else {
                color1 = '#E8D5F5';
                color2 = '#D9C3E8';
            }

            const gradient = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.height);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            ctx.fillStyle = gradient;
            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);

            // ë²½ëŒ í…Œë‘ë¦¬
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

            // ë²½ëŒ í•˜ì´ë¼ì´íŠ¸
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fillRect(brick.x + 5, brick.y + 5, brick.width - 10, 8);

            // HP í‘œì‹œ
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 16px Fredoka';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(brick.hp, brick.x + brick.width / 2, brick.y + brick.height / 2);

            ctx.restore();
        }
        function drawMirrorball(mb, isBig = false) {
            ctx.save();
            ctx.translate(mb.x, mb.y);

            if (isBig && stage === 1) {
                // 1ë‹¨ê³„ í° ë¯¸ëŸ¬ë³¼ - ì€ìƒ‰ + ë°˜ì§ì„

                // ë¹›ë‚˜ëŠ” íš¨ê³¼
                const glowGradient = ctx.createRadialGradient(0, 0, mb.radius * 0.3, 0, 0, mb.radius + 20);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                glowGradient.addColorStop(0.5, 'rgba(220, 220, 255, 0.4)');
                glowGradient.addColorStop(1, 'rgba(200, 200, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, mb.radius + 20, 0, Math.PI * 2);
                ctx.fill();

                // ì€ìƒ‰ ë¯¸ëŸ¬ë³¼ ë³¸ì²´
                const silverGradient = ctx.createRadialGradient(-mb.radius * 0.3, -mb.radius * 0.3, 0, 0, 0, mb.radius);
                silverGradient.addColorStop(0, '#FFFFFF');
                silverGradient.addColorStop(0.3, '#E8E8E8');
                silverGradient.addColorStop(0.6, '#C0C0C0');
                silverGradient.addColorStop(1, '#A0A0A0');
                ctx.fillStyle = silverGradient;
                ctx.beginPath();
                ctx.arc(0, 0, mb.radius, 0, Math.PI * 2);
                ctx.fill();

                // ë°˜ì§ì´ëŠ” ë©´ë“¤
                mb.sparkleAngle += 0.02;
                const segments = 10;
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < segments; j++) {
                        const angle = (i / segments) * Math.PI * 2 + mb.sparkleAngle;
                        const startAngle = angle;
                        const endAngle = angle + (Math.PI * 2 / segments);
                        const innerR = (j / segments) * mb.radius;
                        const outerR = ((j + 1) / segments) * mb.radius;

                        // ë°˜ì§ì„ íš¨ê³¼
                        const sparkle = Math.sin(mb.sparkleAngle * 2 + i + j) * 0.3 + 0.7;
                        const brightness = Math.floor(150 + sparkle * 105);
                        ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;

                        ctx.beginPath();
                        ctx.arc(0, 0, outerR, startAngle, endAngle);
                        ctx.arc(0, 0, innerR, endAngle, startAngle, true);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.ellipse(-mb.radius * 0.3, -mb.radius * 0.3, mb.radius * 0.3, mb.radius * 0.25, -0.5, 0, Math.PI * 2);
                ctx.fill();

                // í…Œë‘ë¦¬
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, mb.radius, 0, Math.PI * 2);
                ctx.stroke();

            } else if (isBig) {
                // 2ë‹¨ê³„ í° ë¯¸ëŸ¬ë³¼ - ë¬´ì§€ê°œìƒ‰
                const glowSize = 100;
                const gradient = ctx.createRadialGradient(0, 0, mb.radius * 0.3, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
                ctx.fill();

                const colors = ['#FFD700', '#FFA500', '#FF69B4', '#00FFFF', '#FF00FF', '#FFFF00'];
                const segments = 8;

                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < segments; j++) {
                        const angle = Date.now() * 0.001;
                        const colorIndex = (i + j + Math.floor(angle)) % colors.length;
                        ctx.fillStyle = colors[colorIndex];

                        const startAngle = (i / segments) * Math.PI * 2;
                        const endAngle = ((i + 1) / segments) * Math.PI * 2;
                        const innerR = (j / segments) * mb.radius;
                        const outerR = ((j + 1) / segments) * mb.radius;

                        ctx.beginPath();
                        ctx.arc(0, 0, outerR, startAngle, endAngle);
                        ctx.arc(0, 0, innerR, endAngle, startAngle, true);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, mb.radius, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                // ì‘ì€ ë¯¸ëŸ¬ë³¼ - í•‘í¬ìƒ‰ (5ì : ì—°í•œ í•‘í¬, 10ì : ì§„í•œ í•‘í¬)
                const isPink5 = mb.points === 5;

                // ë°˜ì§ì´ëŠ” íš¨ê³¼
                const glowSize = mb.radius + 10;
                const glowGradient = ctx.createRadialGradient(0, 0, mb.radius * 0.3, 0, 0, glowSize);
                glowGradient.addColorStop(0, isPink5 ? 'rgba(255, 182, 193, 0.6)' : 'rgba(255, 105, 180, 0.8)');
                glowGradient.addColorStop(1, 'rgba(255, 182, 193, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // ë¯¸ëŸ¬ë³¼ ë³¸ì²´
                const bodyGradient = ctx.createRadialGradient(-mb.radius * 0.3, -mb.radius * 0.3, 0, 0, 0, mb.radius);
                if (isPink5) {
                    bodyGradient.addColorStop(0, '#FFFFFF');
                    bodyGradient.addColorStop(0.4, '#FFB6C1');
                    bodyGradient.addColorStop(1, '#FFC0CB');
                } else {
                    bodyGradient.addColorStop(0, '#FFAEC9');
                    bodyGradient.addColorStop(0.4, '#FF69B4');
                    bodyGradient.addColorStop(1, '#FF1493');
                }
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.arc(0, 0, mb.radius, 0, Math.PI * 2);
                ctx.fill();

                // ë°˜ì§ì´ëŠ” ë©´ë“¤
                const segments = 6;
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2 + Date.now() * 0.001;
                    const sparkle = Math.sin(Date.now() * 0.003 + i) * 0.3 + 0.7;

                    if (isPink5) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${sparkle * 0.5})`;
                    } else {
                        ctx.fillStyle = `rgba(255, 182, 193, ${sparkle * 0.6})`;
                    }

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, mb.radius, angle, angle + Math.PI / 3);
                    ctx.closePath();
                    ctx.fill();
                }

                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.ellipse(-mb.radius * 0.3, -mb.radius * 0.3, mb.radius * 0.3, mb.radius * 0.25, -0.5, 0, Math.PI * 2);
                ctx.fill();

                // í…Œë‘ë¦¬
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, mb.radius, 0, Math.PI * 2);
                ctx.stroke();
            }

            // í° ë¯¸ëŸ¬ë³¼ ì²´ë ¥ë°”
            if (isBig) {
                const barWidth = 100;
                const barHeight = 12;
                const barY = mb.radius + 15;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight);

                const hpPercent = mb.hp / mb.maxHp;
                ctx.fillStyle = hpPercent > 0.5 ? '#00FF00' : hpPercent > 0.25 ? '#FFFF00' : '#FF0000';
                ctx.fillRect(-barWidth / 2, barY, barWidth * hpPercent, barHeight);

                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(-barWidth / 2, barY, barWidth, barHeight);
            }

            ctx.restore();
        }

        // ë³´ìƒ ê·¸ë¦¬ê¸°
        function drawReward(reward) {
            ctx.save();
            ctx.translate(reward.x, reward.y);
            ctx.rotate(reward.rotation);

            if (reward.type === 'candy') {
                // ê·€ì—¬ìš´ ì‚¬íƒ• ë””ìì¸
                const candyColors = [
                    { main: '#FFB6E1', stripe: '#FFD4E5' }, // íŒŒìŠ¤í…” í•‘í¬
                    { main: '#C5DEFF', stripe: '#E8F2FF' }, // íŒŒìŠ¤í…” í•˜ëŠ˜
                    { main: '#FFFACD', stripe: '#FFFFED' }, // íŒŒìŠ¤í…” ë…¸ë‘
                    { main: '#D4F4DD', stripe: '#E8F9EC' }, // íŒŒìŠ¤í…” ì—°ë‘
                    { main: '#E8D5F5', stripe: '#F5EBFF' }, // íŒŒìŠ¤í…” ë³´ë¼
                ];
                const colorSet = candyColors[Math.floor(Math.random() * candyColors.length)];

                // ì‚¬íƒ• ëª¸ì²´ (ë‘¥ê¸€ê²Œ)
                ctx.fillStyle = colorSet.main;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();

                // ì‚¬íƒ• í…Œë‘ë¦¬
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.stroke();

                // ë‚˜ì„ í˜• ìŠ¤íŠ¸ë¼ì´í”„
                ctx.strokeStyle = colorSet.stripe;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const angle = (i / 3) * Math.PI * 2;
                    ctx.arc(0, 0, 5, angle, angle + Math.PI / 1.5);
                    ctx.stroke();
                }

                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(-3, -3, 3, 0, Math.PI * 2);
                ctx.fill();

            } else if (reward.type === 'star') {
                // ë²½ëŒ íŒŒê´´ ë³„ ì´í™íŠ¸
                ctx.fillStyle = '#B794F6';
                ctx.beginPath();
                for (let j = 0; j < 5; j++) {
                    const angle = (j / 5) * Math.PI * 2 - Math.PI / 2;
                    const outerR = 6;
                    const innerR = 3;

                    if (j === 0) {
                        ctx.moveTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
                    } else {
                        ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
                    }

                    const innerAngle = angle + Math.PI / 5;
                    ctx.lineTo(Math.cos(innerAngle) * innerR, Math.sin(innerAngle) * innerR);
                }
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.stroke();

            } else {
                // ë³´ì„
                ctx.fillStyle = '#B794F6';
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.lineTo(6, -2);
                ctx.lineTo(4, 6);
                ctx.lineTo(-4, 6);
                ctx.lineTo(-6, -2);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.stroke();

                // ë°˜ì§ì„
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillRect(-2, -4, 4, 4);
            }

            ctx.restore();
        }

        // ê²Œì„ ì—…ë°ì´íŠ¸
        function update() {
            if (gameState !== 'playing') return;

            // íŒ ì´ë™
            if (keys['ArrowLeft'] || touchingLeft) {
                paddle.x -= paddle.speed;
            }
            if (keys['ArrowRight'] || touchingRight) {
                paddle.x += paddle.speed;
            }
            paddle.x = Math.max(0, Math.min(800 - paddle.width, paddle.x));

            // êµ¬ìŠ¬ ì´ë™
            if (ball.active) {
                ball.x += ball.dx;
                ball.y += ball.dy;

                // ë²½ ì¶©ëŒ
                if (ball.x - ball.radius < 0 || ball.x + ball.radius > 800) {
                    ball.dx *= -1;
                }
                if (ball.y - ball.radius < 0) {
                    ball.dy *= -1;
                }

                // íŒ ì¶©ëŒ
                if (checkRectCircleCollision(paddle, ball) && ball.dy > 0) {
                    ball.dy *= -1;
                    const hitPos = (ball.x - paddle.x) / paddle.width;
                    ball.dx = (hitPos - 0.5) * 10;
                }

                // ë°”ë‹¥ì— ë–¨ì–´ì§ - ê²Œì„ ì˜¤ë²„
                if (ball.y - ball.radius > 600) {
                    gameState = 'gameover';
                    clearInterval(timerInterval);
                    saveHighScore(score);

                    document.getElementById('finalScore').textContent = score + 'ì ';
                    const msg = stage === 2 ? 'ğŸ’ 2ë‹¨ê³„ ë„ì „!' : 'ğŸŒŸ 1ë‹¨ê³„ ë„ì „!';
                    document.getElementById('clearMessage').textContent = msg;

                    displayRankings();
                    document.getElementById('gameOverScreen').style.display = 'flex';
                    return;
                }

                // ì‘ì€ ë¯¸ëŸ¬ë³¼ ì¶©ëŒ
                mirrorballs.forEach((mb, index) => {
                    if (checkCircleCollision(ball, mb)) {
                        ball.dy *= -1;
                        score += mb.points;
                        document.getElementById('score').textContent = score;
                        createRewards(mb.x, mb.y, 'small');
                        mirrorballs.splice(index, 1);
                    }
                });

                // í° ë¯¸ëŸ¬ë³¼ ì¶©ëŒ
                if (bigMirrorball && checkCircleCollision(ball, bigMirrorball)) {
                    ball.dy *= -1;
                    bigMirrorball.hp--;
                    score += 5;
                    document.getElementById('score').textContent = score;

                    if (bigMirrorball.hp <= 0) {
                        score += 300; // ì¤‘ì•™ ë¯¸ëŸ¬ë³¼ í„°ì§€ë©´ 300ì 
                        document.getElementById('score').textContent = score;
                        createRewards(bigMirrorball.x, bigMirrorball.y, 'big');
                        bigMirrorball = null;

                        // 1ë‹¨ê³„ í´ë¦¬ì–´ - 2ë‹¨ê³„ë¡œ ì „í™˜
                        if (stage === 1) {
                            setTimeout(() => clearStage1(), 1000);
                        }
                    }
                }

                // ë²½ëŒ ì¶©ëŒ
                bricks.forEach((brick, index) => {
                    if (checkRectCircleCollision(brick, ball)) {
                        // ì¶©ëŒ ë°©í–¥ íŒë‹¨
                        const ballCenterX = ball.x;
                        const ballCenterY = ball.y;
                        const brickCenterX = brick.x + brick.width / 2;
                        const brickCenterY = brick.y + brick.height / 2;

                        const dx = ballCenterX - brickCenterX;
                        const dy = ballCenterY - brickCenterY;

                        if (Math.abs(dx / brick.width) > Math.abs(dy / brick.height)) {
                            ball.dx *= -1;
                        } else {
                            ball.dy *= -1;
                        }

                        brick.hp--;
                        score += 10;
                        document.getElementById('score').textContent = score;

                        // ë²½ëŒ íŒŒê´´ ì´í™íŠ¸
                        createRewards(brick.x + brick.width / 2, brick.y + brick.height / 2, 'brick');

                        if (brick.hp <= 0) {
                            bricks.splice(index, 1);
                        }
                    }
                });
            }

            // ì›€ì§ì´ëŠ” ë¯¸ëŸ¬ë³¼ (2ë‹¨ê³„)
            if (stage === 2) {
                mirrorballs.forEach(mb => {
                    if (mb.moving) {
                        mb.x += mb.dx;
                        mb.y += mb.dy;

                        if (mb.x - mb.radius < 0 || mb.x + mb.radius > 800) {
                            mb.dx *= -1;
                        }
                        if (mb.y - mb.radius < 0 || mb.y + mb.radius > 400) {
                            mb.dy *= -1;
                        }
                    }
                });
            }

            // ë³´ìƒ ë–¨ì–´ì§
            rewards.forEach((reward, index) => {
                reward.x += reward.dx;
                reward.y += reward.dy;
                reward.dy += 0.3; // ì¤‘ë ¥
                reward.rotation += reward.rotationSpeed;

                if (reward.y > 650) {
                    rewards.splice(index, 1);
                }
            });
        }

        // ê²Œì„ ê·¸ë¦¬ê¸°
        function draw() {
            drawBackground();

            if (gameState === 'playing') {
                drawPaddle();
                if (ball.active) drawBall();

                bricks.forEach(brick => drawBrick(brick));
                mirrorballs.forEach(mb => drawMirrorball(mb, false));
                if (bigMirrorball) drawMirrorball(bigMirrorball, true);

                rewards.forEach(reward => drawReward(reward));
            }
        }

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            ctx.clearRect(0, 0, 800, 600);
            draw();
            update();
            requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹œì‘ (ì–´ë””ë“  í„°ì¹˜í•˜ë©´ ì‹œì‘)
        const startScreen = document.getElementById('startScreen');
        const startHandler = (e) => {
            if (gameState === 'start' || gameState === 'gameover') {
                if (e.type === 'touchstart' && e.cancelable) e.preventDefault();
                startGame();
            }
        };
        startScreen.addEventListener('click', startHandler);
        startScreen.addEventListener('touchstart', startHandler, { passive: false });

        // 2ë‹¨ê³„ ì „í™˜ (ì–´ë””ë“  í„°ì¹˜í•˜ë©´ ì‹œì‘)
        const transitionScreen = document.getElementById('stageTransition');
        const transitionHandler = (e) => {
            if (gameState === 'transition') {
                if (e.type === 'touchstart' && e.cancelable) e.preventDefault();
                startStage2();
            }
        };
        transitionScreen.addEventListener('click', transitionHandler);
        transitionScreen.addEventListener('touchstart', transitionHandler, { passive: false });

        loadHighScores();
        gameLoop();
    </script>
</body>

</html>
